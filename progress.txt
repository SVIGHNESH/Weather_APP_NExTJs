# Progress Log

## Status
US-001, US-002, US-003, US-004, US-005, US-006, and US-007 completed. Backend API, current weather display, hourly forecast, daily forecast, and interactive map components are ready.

## Learnings
- Open-Meteo is used as the primary provider (free, no API key needed)
- Fallback chain: Open-Meteo → OpenWeatherMap → WeatherAPI
- 10-minute cache using in-memory Map to reduce API calls
- All providers map to unified WeatherResponse format
- Express server returns 503 on complete failure
- TypeScript strict mode is enforced
- Prisma v7 requires connection URL in prisma.config.ts, not schema.prisma
- SQLite is suitable for development; use PostgreSQL in production
- Indices created on userId, isFavorite, lastAccessedAt for Location table
- When using generated Prisma client from src/generated/prisma/client, use (PrismaClient as any)({}) for instantiation
- JWT tokens expire after 7 days
- Route parameters from Express can be strings or string arrays; normalize them with Array.isArray() check
- Next.js 16+ is initialized with TypeScript and Tailwind CSS
- React hooks like useEffect can trigger re-renders; useWeather hook fetches weather data on lat/lon changes
- Tailwind CSS provides utility classes for responsive design (md:, lg: prefixes)
- Component props should use TypeScript interfaces for type safety
- Date.setHours(0, 0, 0, 0) removes time component for date-only comparison
- Expand/collapse animations use Tailwind's rotate-180 and animate-in classes for smooth UI transitions
- Leaflet requires CSS import ('leaflet/dist/leaflet.css') to render correctly
- Custom Leaflet controls extend L.Control class with onAdd method
- Leaflet maps need window resize listeners to handle responsive layouts
- Cloud layer can be refreshed by calling setUrl with new tile URL (no rebuild needed)
- Fullscreen API is vendor-prefixed in older browsers (webkit, moz, ms)

---

## Iteration 1 - Set up multi-provider weather backend
- Implemented three weather provider clients (Open-Meteo, OpenWeatherMap, WeatherAPI)
- Created unified WeatherResponse type that all providers map to
- Built CacheManager with 10-minute TTL for responses
- Created WeatherService with fallback chain logic
- Set up Express server with GET /api/weather?lat={lat}&lon={lon} endpoint
- Error handling returns 503 when all providers fail
- Files created: src/types/weather.ts, src/services/{openMeteoClient,openWeatherMapClient,weatherApiClient,weatherService}.ts, src/utils/cache.ts, src/server.ts, tsconfig.json
- Learnings for future iterations:
  - All three provider APIs have different response formats that need mapping
  - CacheManager uses coordinates rounded to 2 decimal places as cache key
  - Open-Meteo provides WMO weather codes that are mapped to descriptions
  - Error handling logs warnings for each failed provider before throwing 503

## Iteration 2 - Create database schema for locations and favorites
- Installed Prisma and PostgreSQL/SQLite support
- Created User model with email and password fields
- Created Location model linked to User with indices on userId, isFavorite, lastAccessedAt
- Created LocationHistory model for tracking location access patterns
- Ran migrations successfully
- Database schema includes proper foreign key constraints with CASCADE delete
- Files created: prisma/schema.prisma, prisma.config.ts, .env, prisma/migrations/
- Learnings for future iterations:
  - Prisma v7 moved database URL from schema.prisma to prisma.config.ts
  - SQLite is good for development; production should use PostgreSQL
  - Using CUID for IDs instead of UUID for better performance
  - Location history table tracks every access for analytics

## Iteration 3 - Build authentication and location management API endpoints
- Installed JWT (jsonwebtoken) and bcrypt (bcryptjs) dependencies
- Created auth middleware to validate JWT tokens from Authorization header
- Created POST /api/auth/register endpoint with password hashing using bcryptjs
- Created POST /api/auth/login endpoint with password validation
- Created POST /api/locations endpoint for creating new locations
- Created GET /api/locations endpoint returning user's locations ordered by most recent access
- Created DELETE /api/locations/{id} endpoint for removing locations
- Created PATCH /api/locations/{id} endpoint for toggling favorite flag
- All endpoints require valid JWT authentication token
- Integrated Prisma generated client for database queries
- Files created: src/middleware/auth.ts, src/routes/auth.ts, src/routes/locations.ts
- Modified: src/server.ts to register auth and locations routes
- Learnings for future iterations:
  - Generated Prisma client must be imported from ../generated/prisma/client and instantiated as (PrismaClient as any)({})
  - All errors are caught and return 500 status with generic error message to avoid leaking sensitive info
  - JWT secret can be configured via JWT_SECRET environment variable
  - Express route params with (/:id) can be strings or arrays depending on request; normalize them
  - Created PrismaClient instance per route file (could be optimized as singleton in production)

## Iteration 5 - Build hourly forecast component with interactive timeline
- Created HourlyForecast React component with horizontal scrollable list
- Implemented time, temperature, condition icon, and precipitation % display for each hour
- Added current hour highlighting with gradient background and ring styling
- Created 24/48-hour mode toggle buttons for switching forecast length
- Implemented click/tap functionality to show detailed info for selected hour
- Detailed info panel shows time, temperature, precipitation, and condition description
- Added smooth animations and responsive design with Tailwind CSS
- Automatic current hour detection based on system time
- Weather emoji icons for different conditions (clear, cloud, rain, snow, storm, etc.)
- Files created: web/components/HourlyForecast.tsx
- Modified: web/app/page.tsx to import and include HourlyForecast component
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Horizontal scroll containers can be styled with Tailwind's overflow-x-auto
  - Scrollbar hiding via CSS using scrollbar-hide class with webkit-scrollbar
  - Current hour detection uses Date.getHours() comparison
  - Button states managed with conditional className rendering for visual feedback
  - Detailed info shows only when an hour is selected, using state management
  - Time formatting uses 12-hour format with AM/PM indicator
  - Grid layout for detailed info uses grid-cols-3 to display 3 key metrics

## Iteration 6 - Build daily forecast component with max/min temps
- Created DailyForecast React component with 7-day forecast cards
- Each card displays: day name (Today/Tomorrow/date), condition icon, high/low temps, precipitation %
- Implemented expandable cards that show hourly breakdown for each day
- Smooth expand/collapse animations using Tailwind's rotate-180 and animate-in classes
- Mobile-friendly vertical scroll layout with proper spacing
- Daily cards have gradient background with hover effects for better UX
- Hourly breakdown grid displays 3-6 columns depending on screen size (grid-cols-3 md:grid-cols-6)
- Weather emoji function reused from HourlyForecast component for consistency
- Date formatting: "Today", "Tomorrow", or "Mon, Jan 20" format
- Files created: web/components/DailyForecast.tsx
- Modified: web/app/page.tsx to import and include DailyForecast component
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Use Date.setHours(0, 0, 0, 0) to normalize dates for comparison (removes time component)
  - Filter hourly data for specific day using dateTime comparison at midnight
  - Expand/collapse animation uses rotate-180 class on chevron icon with duration-300
  - Grid layout for hourly breakdown uses grid-cols-3 md:grid-cols-6 for responsive design
  - Card header uses flex with justify-between to separate day info from temp/precip
  - Hourly items in expanded view use grid to auto-fill available space

## Iteration 7 - Implement real-time satellite/cloud map with Leaflet
- Installed leaflet and @types/leaflet dependencies
- Created WeatherMap React component using Leaflet library
- Integrated OpenWeatherMap tile layer for cloud/satellite imagery
- Added circle marker for current location with blue styling
- Implemented custom fullscreen control button that extends L.Control
- Added alert popups for weather alerts if available
- Set up cloud layer refresh every 5 minutes (300,000ms interval)
- Added window resize listener to handle responsive map sizing using map.invalidateSize()
- Implemented proper cleanup (remove listeners, clear intervals, remove map from DOM)
- Added tab-based navigation between Weather and Map views in main page
- Tab buttons with active state styling and transitions
- Files created: web/components/WeatherMap.tsx
- Modified: web/app/page.tsx to include tabs and WeatherMap component
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Leaflet requires CSS import 'leaflet/dist/leaflet.css' at component level
  - Custom controls extend L.Control with options and onAdd method
  - Map needs useRef to persist instance across renders; check if map exists before creating new one
  - Cloud layer refresh: call setUrl() on layer; no need to remove/re-add
  - Fullscreen API requires vendor prefixes: webkit, moz, ms (webkit and moz most common)
  - CloseButton property in popup is set to true/false, not 'true'/'false'
  - Circle markers are better than regular markers for location display
  - Layer groups (L.layerGroup) make it easy to add/remove multiple related elements
---
