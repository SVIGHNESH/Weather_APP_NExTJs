# Progress Log

## Status
US-001, US-002, US-003, US-004, US-005, US-006, and US-007 completed. Backend API, current weather display, hourly forecast, daily forecast, and interactive map components are ready.

## Learnings
- Open-Meteo is used as the primary provider (free, no API key needed)
- Fallback chain: Open-Meteo â†’ OpenWeatherMap â†’ WeatherAPI
- 10-minute cache using in-memory Map to reduce API calls
- All providers map to unified WeatherResponse format
- Express server returns 503 on complete failure
- TypeScript strict mode is enforced
- Prisma v7 requires connection URL in prisma.config.ts, not schema.prisma
- SQLite is suitable for development; use PostgreSQL in production
- Indices created on userId, isFavorite, lastAccessedAt for Location table
- When using generated Prisma client from src/generated/prisma/client, use (PrismaClient as any)({}) for instantiation
- JWT tokens expire after 7 days
- Route parameters from Express can be strings or string arrays; normalize them with Array.isArray() check
- Next.js 16+ is initialized with TypeScript and Tailwind CSS
- React hooks like useEffect can trigger re-renders; useWeather hook fetches weather data on lat/lon changes
- Tailwind CSS provides utility classes for responsive design (md:, lg: prefixes)
- Component props should use TypeScript interfaces for type safety
- Date.setHours(0, 0, 0, 0) removes time component for date-only comparison
- Expand/collapse animations use Tailwind's rotate-180 and animate-in classes for smooth UI transitions
- Leaflet requires CSS import ('leaflet/dist/leaflet.css') to render correctly
- Custom Leaflet controls extend L.Control class with onAdd method
- Leaflet maps need window resize listeners to handle responsive layouts
- Cloud layer can be refreshed by calling setUrl with new tile URL (no rebuild needed)
- Fullscreen API is vendor-prefixed in older browsers (webkit, moz, ms)

---

## Iteration 1 - Set up multi-provider weather backend
- Implemented three weather provider clients (Open-Meteo, OpenWeatherMap, WeatherAPI)
- Created unified WeatherResponse type that all providers map to
- Built CacheManager with 10-minute TTL for responses
- Created WeatherService with fallback chain logic
- Set up Express server with GET /api/weather?lat={lat}&lon={lon} endpoint
- Error handling returns 503 when all providers fail
- Files created: src/types/weather.ts, src/services/{openMeteoClient,openWeatherMapClient,weatherApiClient,weatherService}.ts, src/utils/cache.ts, src/server.ts, tsconfig.json
- Learnings for future iterations:
  - All three provider APIs have different response formats that need mapping
  - CacheManager uses coordinates rounded to 2 decimal places as cache key
  - Open-Meteo provides WMO weather codes that are mapped to descriptions
  - Error handling logs warnings for each failed provider before throwing 503

## Iteration 2 - Create database schema for locations and favorites
- Installed Prisma and PostgreSQL/SQLite support
- Created User model with email and password fields
- Created Location model linked to User with indices on userId, isFavorite, lastAccessedAt
- Created LocationHistory model for tracking location access patterns
- Ran migrations successfully
- Database schema includes proper foreign key constraints with CASCADE delete
- Files created: prisma/schema.prisma, prisma.config.ts, .env, prisma/migrations/
- Learnings for future iterations:
  - Prisma v7 moved database URL from schema.prisma to prisma.config.ts
  - SQLite is good for development; production should use PostgreSQL
  - Using CUID for IDs instead of UUID for better performance
  - Location history table tracks every access for analytics

## Iteration 3 - Build authentication and location management API endpoints
- Installed JWT (jsonwebtoken) and bcrypt (bcryptjs) dependencies
- Created auth middleware to validate JWT tokens from Authorization header
- Created POST /api/auth/register endpoint with password hashing using bcryptjs
- Created POST /api/auth/login endpoint with password validation
- Created POST /api/locations endpoint for creating new locations
- Created GET /api/locations endpoint returning user's locations ordered by most recent access
- Created DELETE /api/locations/{id} endpoint for removing locations
- Created PATCH /api/locations/{id} endpoint for toggling favorite flag
- All endpoints require valid JWT authentication token
- Integrated Prisma generated client for database queries
- Files created: src/middleware/auth.ts, src/routes/auth.ts, src/routes/locations.ts
- Modified: src/server.ts to register auth and locations routes
- Learnings for future iterations:
  - Generated Prisma client must be imported from ../generated/prisma/client and instantiated as (PrismaClient as any)({})
  - All errors are caught and return 500 status with generic error message to avoid leaking sensitive info
  - JWT secret can be configured via JWT_SECRET environment variable
  - Express route params with (/:id) can be strings or arrays depending on request; normalize them
  - Created PrismaClient instance per route file (could be optimized as singleton in production)

## Iteration 5 - Build hourly forecast component with interactive timeline
- Created HourlyForecast React component with horizontal scrollable list
- Implemented time, temperature, condition icon, and precipitation % display for each hour
- Added current hour highlighting with gradient background and ring styling
- Created 24/48-hour mode toggle buttons for switching forecast length
- Implemented click/tap functionality to show detailed info for selected hour
- Detailed info panel shows time, temperature, precipitation, and condition description
- Added smooth animations and responsive design with Tailwind CSS
- Automatic current hour detection based on system time
- Weather emoji icons for different conditions (clear, cloud, rain, snow, storm, etc.)
- Files created: web/components/HourlyForecast.tsx
- Modified: web/app/page.tsx to import and include HourlyForecast component
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Horizontal scroll containers can be styled with Tailwind's overflow-x-auto
  - Scrollbar hiding via CSS using scrollbar-hide class with webkit-scrollbar
  - Current hour detection uses Date.getHours() comparison
  - Button states managed with conditional className rendering for visual feedback
  - Detailed info shows only when an hour is selected, using state management
  - Time formatting uses 12-hour format with AM/PM indicator
  - Grid layout for detailed info uses grid-cols-3 to display 3 key metrics

## Iteration 6 - Build daily forecast component with max/min temps
- Created DailyForecast React component with 7-day forecast cards
- Each card displays: day name (Today/Tomorrow/date), condition icon, high/low temps, precipitation %
- Implemented expandable cards that show hourly breakdown for each day
- Smooth expand/collapse animations using Tailwind's rotate-180 and animate-in classes
- Mobile-friendly vertical scroll layout with proper spacing
- Daily cards have gradient background with hover effects for better UX
- Hourly breakdown grid displays 3-6 columns depending on screen size (grid-cols-3 md:grid-cols-6)
- Weather emoji function reused from HourlyForecast component for consistency
- Date formatting: "Today", "Tomorrow", or "Mon, Jan 20" format
- Files created: web/components/DailyForecast.tsx
- Modified: web/app/page.tsx to import and include DailyForecast component
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Use Date.setHours(0, 0, 0, 0) to normalize dates for comparison (removes time component)
  - Filter hourly data for specific day using dateTime comparison at midnight
  - Expand/collapse animation uses rotate-180 class on chevron icon with duration-300
  - Grid layout for hourly breakdown uses grid-cols-3 md:grid-cols-6 for responsive design
  - Card header uses flex with justify-between to separate day info from temp/precip
  - Hourly items in expanded view use grid to auto-fill available space

## Iteration 11 - Implement data persistence and offline mode
- Created useWeatherCache hook to manage weather data caching in localStorage
- Cache key generated from rounded coordinates (rounded to 2 decimal places for consistency)
- Cache expires after 1 hour (3,600,000ms); expired entries are automatically removed
- Returns offline status by monitoring navigator.onLine and window online/offline events
- Displays "last updated" time using formatLastUpdated helper function (human-readable format)
- Created service worker (public/sw.js) with cache-first strategy for static assets
- Service worker includes network-first strategy for API calls with fallback to cached responses
- Cache-first for _next/ resources, JS, CSS, fonts, images; network-first for API and HTML
- Service worker automatically cleans up old caches on activation
- Created useServiceWorker hook to register service worker on app load
- Updated useWeather hook to use caching:
  - Tries to fetch fresh data first
  - Falls back to cached data if fetch fails or offline
  - Sets appropriate error messages for offline vs. error states
  - 8-second timeout on API calls to handle slow networks gracefully
- Updated main page to:
  - Show offline indicator (ðŸ”´) and last updated time in subtitle
  - Display blue banner (not red) when showing cached data
  - Pass offline and isCached status from useWeather
- Files created: web/hooks/useWeatherCache.ts, web/hooks/useServiceWorker.ts, web/public/sw.js
- Modified: web/hooks/useWeather.ts, web/app/page.tsx
- TypeScript compilation passes with no errors
- Learnings for future iterations:
  - Cache key should include rounded coordinates for consistency across views
  - Cache entry structure: { data, timestamp, expiresAt } for expiration checking
  - formatLastUpdated uses diffMs / 60000 for minutes, then hours, then full date
  - Service worker: cache-first for static assets (fast), network-first for API (fresh)
  - Service worker catches API errors and returns cached responses from previous calls
  - navigator.onLine is not always reliable; use addEventListener for 'online' and 'offline'
  - AbortSignal.timeout(ms) for fetch timeout is modern API; use AbortController for older browsers
  - Error messages should differentiate between offline and network failure
---
